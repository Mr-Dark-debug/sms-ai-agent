Here's the detailed prompt you can copy and paste:

---

## PROMPT TO FIX SMS AI AGENT - SMS DETECTION ISSUE

```
I have an SMS AI Agent running in Termux on Android that is not detecting or catching incoming SMS messages. Even after sending SMS to the device, the app doesn't process them.

GitHub Repository: https://github.com/Mr-Dark-debug/sms-ai-agent

Please examine and fix the following files:
- services/sms_handler.py (main SMS handling with listener)
- main.py (entry point with daemon mode)

=== ROOT CAUSE ANALYSIS ===

PROBLEM 1: No Real-Time SMS Detection
- Termux API does NOT provide a real-time SMS broadcast receiver
- The app uses polling via `termux-sms-list` every 10 seconds
- This only queries the SMS inbox database, not real-time incoming messages
- This is a fundamental Termux limitation

PROBLEM 2: Permission Verification Gap
- The `_check_availability()` method only checks if Termux:API is installed using `termux-telephony-deviceinfo`
- It does NOT verify that SMS permissions are actually granted
- The app may report "available" even without SMS read/send permissions

PROBLEM 3: Message Direction Detection Bug
- Current code: `direction="incoming" if msg_data.get("type", 1) == 1 else "outgoing"`
- Android SMS type values are:
  * 1 = MESSAGE_TYPE_INBOX (received)
  * 2 = MESSAGE_TYPE_SENT
  * 3 = MESSAGE_TYPE_DRAFT
  * 4 = MESSAGE_TYPE_OUTBOX
  * 5 = MESSAGE_TYPE_FAILED
  * 6 = MESSAGE_TYPE_QUEUED
- The logic misses draft, outbox, failed, queued types

PROBLEM 4: Listener Loop Issues
- The `seen_ids` set uses: `f"{msg.phone_number}_{msg.timestamp.isoformat()}"`
- Microsecond differences in timestamps could cause duplicates
- First run adds ALL existing messages to seen_ids
- No logging to debug if polling is actually working

PROBLEM 5: Poll Interval Too Long
- Current: 10 seconds between polls
- Should be 2-5 seconds for near-real-time detection

=== REQUIRED FIXES ===

FIX 1: Improve _check_availability() method in services/sms_handler.py

Replace the current method with:

```python
def _check_availability(self) -> bool:
    """
    Check if Termux API is available AND SMS permissions are granted.
    
    Returns:
        True if Termux API commands are available and SMS permissions granted
    """
    try:
        # First check if termux-api commands exist
        result = subprocess.run(
            ["which", "termux-sms-list"],
            capture_output=True,
            timeout=5
        )
        if result.returncode != 0:
            logger.error("termux-sms-list command not found")
            return False
        
        # Actually try to list SMS (this tests permissions)
        result = subprocess.run(
            ["termux-sms-list", "-l", "1"],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        if result.returncode != 0:
            error = result.stderr.strip() if result.stderr else "Unknown error"
            logger.error(f"SMS list failed: {error}")
            
            # Check for permission-related errors
            if "permission" in error.lower() or "denied" in error.lower():
                logger.error("SMS permission not granted!")
                logger.error("Grant permission: Settings → Apps → Termux:API → Permissions → SMS")
            return False
        
        # Also verify we can send (different permission)
        try:
            send_check = subprocess.run(
                ["which", "termux-sms-send"],
                capture_output=True,
                timeout=5
            )
            if send_check.returncode != 0:
                logger.warning("termux-sms-send not found")
        except Exception:
            pass
            
        logger.info("SMS permissions verified successfully")
        return True
        
    except subprocess.TimeoutExpired:
        logger.error("Availability check timed out")
        return False
    except FileNotFoundError:
        logger.error("Termux API commands not found")
        return False
    except Exception as e:
        logger.error(f"Availability check failed: {e}")
        return False
```

FIX 2: Fix message direction detection in list_messages() method in services/sms_handler.py

Add this constant at the top of the SMSHandler class:

```python
# Android SMS type values
SMS_TYPE_MAP = {
    1: "incoming",    # MESSAGE_TYPE_INBOX
    2: "outgoing",    # MESSAGE_TYPE_SENT
    3: "draft",       # MESSAGE_TYPE_DRAFT
    4: "outgoing",    # MESSAGE_TYPE_OUTBOX
    5: "failed",      # MESSAGE_TYPE_FAILED
    6: "outgoing",    # MESSAGE_TYPE_QUEUED
}
```

Then in the list_messages() method, replace the direction assignment:

```python
# OLD CODE:
# direction="incoming" if msg_data.get("type", 1) == 1 else "outgoing"

# NEW CODE:
msg_type = msg_data.get("type", 1)
direction = self.SMS_TYPE_MAP.get(msg_type, "incoming")
```

FIX 3: Completely rewrite _listener_loop() method with better logging and debugging

```python
def _listener_loop(self, poll_interval: int) -> None:
    """
    Listener loop for polling messages.
    
    Uses polling since Termux API doesn't support real-time SMS broadcast.
    Improved with better logging and unique ID generation.
    
    Args:
        poll_interval: Seconds between polls
    """
    seen_ids = set()
    first_run = True
    poll_count = 0
    
    logger.info(f"SMS listener loop started (poll interval: {poll_interval}s)")
    
    while self._running:
        poll_count += 1
        try:
            # Get recent messages
            messages = self.list_messages(limit=20)
            logger.debug(f"Poll #{poll_count}: Found {len(messages)} total messages")
            
            new_incoming = []
            
            for msg in messages:
                # Only process incoming messages
                if msg.direction != "incoming":
                    continue
                
                # Create more robust unique ID using message content
                import hashlib
                content_preview = msg.message[:50] if msg.message else ""
                unique_string = f"{msg.phone_number}|{msg.timestamp.isoformat()}|{content_preview}"
                msg_id = hashlib.sha256(unique_string.encode()).hexdigest()[:16]
                
                if msg_id not in seen_ids:
                    seen_ids.add(msg_id)
                    
                    # Skip processing on first run (just populate seen_ids)
                    if not first_run:
                        new_incoming.append(msg)
                        logger.info(
                            f"NEW SMS DETECTED: From {msg.phone_number} - "
                            f"'{msg.message[:30]}{'...' if len(msg.message) > 30 else ''}'"
                        )
            
            # Process new messages through callbacks
            if new_incoming:
                logger.info(f"Processing {len(new_incoming)} new incoming message(s)")
                for msg in new_incoming:
                    logger.info(f"Dispatching to {len(self._callbacks)} callback(s)")
                    for callback in self._callbacks:
                        try:
                            callback(msg)
                        except Exception as e:
                            logger.error(f"Callback error: {e}", exc_info=True)
            
            # Mark first run complete
            if first_run:
                logger.info(f"Initial scan complete. Tracking {len(seen_ids)} existing messages")
                first_run = False
                
        except Exception as e:
            logger.error(f"Listener loop error: {e}", exc_info=True)
        
        # Wait before next poll
        import time
        time.sleep(poll_interval)
```

FIX 4: Add diagnostic method to SMSHandler class

```python
def diagnose(self) -> Dict[str, Any]:
    """
    Run diagnostic checks for SMS functionality.
    
    Returns:
        Dictionary with diagnostic results
    """
    results = {
        "termux_api_installed": False,
        "sms_list_works": False,
        "sms_send_available": False,
        "device_info": None,
        "sample_messages": [],
        "errors": []
    }
    
    # Check 1: termux-sms-list exists
    try:
        check = subprocess.run(["which", "termux-sms-list"], capture_output=True, timeout=5)
        results["termux_api_installed"] = check.returncode == 0
    except Exception as e:
        results["errors"].append(f"API check failed: {e}")
    
    # Check 2: Can list SMS
    try:
        result = subprocess.run(
            ["termux-sms-list", "-l", "5"],
            capture_output=True,
            text=True,
            timeout=15
        )
        if result.returncode == 0:
            results["sms_list_works"] = True
            try:
                messages = json.loads(result.stdout)
                results["sample_messages"] = [
                    {
                        "number": m.get("number", m.get("address", "unknown")),
                        "preview": m.get("body", m.get("text", ""))[:50],
                        "type": m.get("type", "unknown")
                    }
                    for m in messages[:3]
                ]
            except json.JSONDecodeError:
                results["errors"].append("Invalid JSON from termux-sms-list")
        else:
            results["errors"].append(f"SMS list failed: {result.stderr}")
    except Exception as e:
        results["errors"].append(f"SMS list test failed: {e}")
    
    # Check 3: termux-sms-send exists
    try:
        check = subprocess.run(["which", "termux-sms-send"], capture_output=True, timeout=5)
        results["sms_send_available"] = check.returncode == 0
    except Exception as e:
        results["errors"].append(f"Send check failed: {e}")
    
    # Check 4: Device info
    try:
        result = subprocess.run(
            ["termux-telephony-deviceinfo"],
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode == 0:
            results["device_info"] = json.loads(result.stdout)
    except Exception as e:
        results["errors"].append(f"Device info failed: {e}")
    
    return results
```

FIX 5: In main.py, add --diagnose command and reduce poll interval

Add to parse_args():
```python
mode_group.add_argument(
    "--diagnose",
    action="store_true",
    help="Run diagnostic checks for SMS functionality"
)
```

Add new function:
```python
def run_diagnosis() -> None:
    """Run diagnostic checks for SMS functionality."""
    from services.sms_handler import SMSHandler
    
    print("\n" + "=" * 50)
    print("SMS AI Agent - Diagnostic Mode")
    print("=" * 50 + "\n")
    
    handler = SMSHandler()
    results = handler.diagnose()
    
    print("1. Termux API Installation")
    print("-" * 30)
    if results["termux_api_installed"]:
        print("   ✓ termux-sms-list is installed")
    else:
        print("   ✗ termux-sms-list NOT found")
        print("   → Run: pkg install termux-api")
    
    print("\n2. SMS List Capability")
    print("-" * 30)
    if results["sms_list_works"]:
        print("   ✓ Can read SMS messages")
        if results["sample_messages"]:
            print(f"   Found {len(results['sample_messages'])} recent messages:")
            for m in results["sample_messages"]:
                print(f"     - {m['number']}: '{m['preview']}...' (type={m['type']})")
    else:
        print("   ✗ Cannot read SMS - permission issue likely")
        print("   → Settings → Apps → Termux:API → Permissions")
        print("   → Enable: SMS, Storage, Phone")
    
    print("\n3. SMS Send Capability")
    print("-" * 30)
    if results["sms_send_available"]:
        print("   ✓ termux-sms-send is available")
    else:
        print("   ✗ termux-sms-send NOT found")
    
    print("\n4. Device Info")
    print("-" * 30)
    if results["device_info"]:
        print(f"   Phone: {results['device_info'].get('phone_number', 'Unknown')}")
        print(f"   Network: {results['device_info'].get('network_operator_name', 'Unknown')}")
    else:
        print("   ⚠ Could not get device info")
    
    if results["errors"]:
        print("\n5. Errors Found")
        print("-" * 30)
        for err in results["errors"]:
            print(f"   • {err}")
    
    print("\n" + "=" * 50)
    
    if not results["sms_list_works"]:
        print("\n⚠ SMS PERMISSION REQUIRED!")
        print("1. Go to: Settings → Apps → Termux:API → Permissions")
        print("2. Enable: SMS")
        print("3. Also check: Settings → Apps → Termux → Permissions")
        print("4. Run this diagnosis again to verify")
    
    print()

# In main() function, add:
if args.diagnose:
    run_diagnosis()
    return 0
```

Also in run_daemon(), change the poll interval:
```python
# OLD: sms_handler.start_listener(poll_interval=10)
# NEW:
sms_handler.start_listener(poll_interval=3)  # 3 seconds for faster detection
```

FIX 6: Add permission check before daemon starts in main.py run_daemon() function

```python
def run_daemon(config: Config) -> None:
    """Run as background daemon."""
    # ... existing initialization ...
    
    sms_handler = SMSHandler(timeout=config.sms.sms_timeout)
    
    # NEW: Verify permissions before starting
    print("\nVerifying SMS permissions...")
    if not sms_handler.is_available:
        print("✗ SMS handler not available!")
        print("\nPossible causes:")
        print("1. Termux:API app not installed")
        print("2. termux-api package not installed (run: pkg install termux-api)")
        print("3. SMS permission not granted")
        print("\nRun: python main.py --diagnose")
        return
    
    # Run diagnosis to confirm everything works
    diag = sms_handler.diagnose()
    if not diag["sms_list_works"]:
        print("✗ Cannot read SMS messages - permission issue!")
        print("Grant permission: Settings → Apps → Termux:API → Permissions → SMS")
        return
    
    print("✓ SMS permissions verified")
    
    # ... rest of daemon code ...
```

=== VERIFICATION STEPS ===

After applying fixes, test with:

1. Run diagnosis:
   python main.py --diagnose

2. Start daemon with debug:
   python main.py --daemon --debug

3. Send test SMS to the device

4. Watch logs for:
   "Poll #X: Found Y total messages"
   "NEW SMS DETECTED: From +1234567890 - 'message content...'"

=== IMPORTANT NOTES ===

1. Termux API limitation: There is NO real-time SMS broadcast in Termux. Polling is the only way.

2. Android 10+ restrictions: SMS permissions require manual grant in Settings.

3. First run behavior: Existing messages are marked as "seen" without triggering callbacks. Only NEW messages after daemon starts will be processed.

4. Reduce poll interval to 2-5 seconds for near-real-time detection.

5. Check both Termux AND Termux:API app permissions - both need SMS permission.

Apply all these fixes and test thoroughly.
```